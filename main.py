import requests
import json

invalid_token = "all_your_base_are_belong_to_us"
app_id = None
base_address = None
server_retry = 5


class APIRequestError(Exception):
    """
    Exception raised for errors generated by API calls

    Attributes:
        req -- request which generated the error
        msg -- error string
        err -- error name
    """
    def __init__(self, err, req, message):
        self.req = req
        self.msg = message
        self.err = err
        super().__init__(f"Failed {req} request, {message}")


class AppIDNotExistError(APIRequestError):
    """
    Exception raised for errors generated because app-id is invalid
    Attributes:
        req -- request which generated the error
        err -- error name
    """
    def __init__(self, req):
        self.req = req
        self.err = 'APP_ID_NOT_EXIST'
        super().__init__(self.err, req, "app-id is invalid.")


class AppIDMissingError(APIRequestError):
    """
    Exception raised for errors generated because app-id header is missing
    Attributes:
        req -- request which generated the error
        err -- error name
    """
    def __init__(self, req):
        self.req = req
        self.err = 'APP_ID_MISSING'
        super().__init__(self.err, req, "app-id header is missing in the request.")


class ParamsNotValidError(APIRequestError):
    """
    Exception raised for errors generated because of invalid parameters
    Attributes:
        req -- request which generated the error
        addr -- address which generated the error
        err -- error name
    """
    def __init__(self, req, addr):
        self.req = req
        self.addr = addr
        self.err = 'PARAMS_NOT_VALID'
        super().__init__(self.err, req, f"invalid parameters for address {addr}.")


class ResourceNotFoundError(APIRequestError):
    """
    Exception raised for errors generated because the requested item was not found
    Attributes:
        req -- request which generated the error
        addr -- address which generated the error
        err -- error name
    """
    def __init__(self, req, addr):
        self.req = req
        self.addr = addr
        self.err = 'RESOURCE_NOT_FOUND'
        super().__init__(self.err, req, f"missing resource for address {addr}.")


class PathNotFoundError(APIRequestError):
    """
    Exception raised for errors generated because of invalid path
    Attributes:
        req -- request which generated the error
        path -- request path
        err -- error number
    """
    def __init__(self, req, path):
        self.req = req
        self.path = path
        self.err = 'PATH_NOT_FOUND'
        super().__init__(self.err, req, f"couldn't find the path: {path}, check controller documentation to validate the URL.")


class ServerError(APIRequestError):
    """
    Exception raised for errors generated because of a server error
    Attributes:
        req -- request which generated the error
        err -- error name
    """
    def __init__(self, req):
        self.req = req
        self.err = 'SERVER_ERROR'
        super().__init__(self.err, req, f"Server error for the {req} request, try again later.")


def handle_error(req, err, addr, server_counter):
    """
    Method to handle errors generated by the plugin

    :param req: request which caused the error
    :param err: error name
    :param addr: address which caused the error
    :param server_counter: if the error is a 'SERVER_ERROR', number of times already attempted to call the request
    :return: if the error is a 'SERVER_ERROR' return 1 to add to the counter of the times attempted requesting data
    """
    if err == 'APP_ID_NOT_EXIST':
        raise AppIDNotExistError(req)
    if err == 'APP_ID_MISSING':
        raise AppIDMissingError(req)
    if err == 'PARAMS_NOT_VALID':
        raise ParamsNotValidError(req, addr)
    if err == 'RESOURCE_NOT_FOUND':
        raise ResourceNotFoundError(req, addr)
    if err == 'PATH_NOT_FOUND':
        raise PathNotFoundError(req, addr)
    if err == 'SERVER_ERROR' and server_counter >= server_retry:
        raise ServerError(req)
    return 1


def create_json(data, filename):
    """
    Given data and a filename, create a file and dump the data onto it in a json format

    :param data: given data
    :param filename: requested filename
    """
    # export the obtained data to a JSON file
    data_json = json.dumps(data)

    with open(filename + ".json", "w") as file:
        file.write(data_json)


def set_creds(creds):
    """
    Method to set the global app_id value to a specific API token
    :param creds: token to set the global api_token holder as
    """
    global app_id
    app_id = creds


def set_api(api):
    """
    Method to set the global base_address value to a specific API's address
    :param api: address of an API
    """
    global base_address
    base_address = api


def connectivity_test(endpoint):
    """
    Method to test connectivity to some API
    :param endpoint: endpoint for the specific API
    """
    global app_id
    if not app_id:
        set_creds(invalid_token)
    address = base_address + endpoint
    response = requests.get(address, headers={'app-id': app_id})
    response_json = response.json()

    """ 
        handle_error handles SERVER_ERROR up to server_retry times
        therefore if handle_error returns to retry, the method will retry connecting
        up to the server_retry limit
    """

    retry = 0
    while 'error' in response_json:
        retry += handle_error("GET", response_json['error'], address, retry)
        response = requests.get(address, headers={'app-id': app_id})
        response_json = response.json()
    else:
        print("Connected successfully!")


def get_item(item, args=None):
    """
    Method to send a GET request for an item from the API
    :param item: item to request for
    :param args: additional arguments
    :return: the obtained item in a json format
    """
    # format args as arg=value such that it could be appended to the address as a1=v1&a2=v2&...&an=vn
    if args:
        formatted_args = [f'{key}={str(args[key])}' for key in args]
    else:
        formatted_args = []
    endpoint = base_address + item + '?' + '&'.join([arg for arg in formatted_args])

    response = requests.get(endpoint, headers={'app-id': app_id})
    response_json = response.json()

    retry = 0
    while 'error' in response_json:
        retry += handle_error("GET", response_json['error'], endpoint, retry)
        response = requests.get(endpoint, headers={'app-id': app_id})
        response_json = response.json()

    return response_json


def get_items(item, to_return=False, amount=None):
    """
    Method to get multiple items of type item from the API
    :param item: item to request for
    :param to_return: should the method return the result or dump to json, default False means dump to json
    :param amount: number of items to request for, default None means get all
    :return: if to_return=True, return the data collected as a list of json objects
    """
    data = []
    current_page = 0
    filename = item + 's'

    while True:
        args = {'page': current_page}

        # get_item fails with exception, dump collected data and re-raise
        # note that server_error should return here only if already retried server_retry times
        try:
            response = get_item(item, args)
        except APIRequestError as e:
            msg = ""
            if len(data) > 0:
                create_json(data, item + 's')
            handle_error("GET", e.err, "", server_retry)

        # obtained data is empty, meaning there's no more data to collect

        if len(response['data']) == 0:
            break

        # append the obtained information and continue
        data.extend(response['data'])

        # limit the size of obtained data to given amount argument
        if amount:
            if len(data) >= amount:
                data = data[:amount]
                break
        current_page += 1

    # export the obtained data to a JSON file
    if not to_return:
        create_json(data, filename)
    else:
        return data


def get_users():
    """
    Create a json file called users.json which holds the entire user database of dummyapi.io
    """
    get_items('user')


def get_posts():
    """
    Create a json file called posts.json which holds some amount of posts and their relevant comments from
    dummyapi.io
    """
    posts = get_items('post', to_return=True, amount=50)
    for post in posts:
        post_id = post['id']
        endpoint = f'post/{post_id}/comment'
        comments = get_items(endpoint, to_return=True)
        post['comments'] = comments

    create_json(posts, 'posts')


def main():
    set_api("https://dummyapi.io/data/v1/")
    # set_creds('INSERT CREDENTIALS HERE')
    connectivity_test('user?limit=1')
    get_users()
    get_posts()


if __name__ == '__main__':
    main()
